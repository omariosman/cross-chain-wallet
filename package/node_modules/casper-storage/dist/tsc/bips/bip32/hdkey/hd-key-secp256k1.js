"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HDKeySecp256k1 = void 0;
const hd_key_1 = require("./hd-key");
const cryptography_1 = require("../../../cryptography");
const _assert_1 = require("@noble/hashes/_assert");
const secp256k1_1 = require("@noble/curves/secp256k1");
const utils_1 = require("../../../utils");
class HDKeySecp256k1 extends hd_key_1.HDKey {
    createNewHDKey(privateKey, chainCode, publicKey) {
        return new HDKeySecp256k1(this.config, privateKey, chainCode, publicKey);
    }
    deriveChild(index) {
        return __awaiter(this, void 0, void 0, function* () {
            const privateKey = this.getPrivateKey();
            const publicKey = yield this.getPublicKey();
            if (!publicKey || !this.chainCode) {
                throw new Error('No publicKey or chainCode set');
            }
            const isHardened = index >= this.getHardenedOffset();
            let data = utils_1.TypeUtils.convertU32ToBytes(index);
            if (isHardened) {
                if (!privateKey) {
                    throw new Error("Cannot derive a hardened child without private key");
                }
                // Hardened child: data = 0x00 || ser256(kpar) || ser32(index)
                data = utils_1.TypeUtils.concatBytes(utils_1.TypeUtils.getBytesOfZero(), privateKey, data);
            }
            else {
                // Normal child: serP(point(kpar)) || ser32(index)
                data = utils_1.TypeUtils.concatBytes(publicKey, data);
            }
            const derivedData = cryptography_1.CryptoUtils.digestSHA512(data, this.getChainCode());
            let derivedPrivateKey = derivedData.key;
            const derivedChainCode = derivedData.chainCode;
            if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(derivedPrivateKey)) {
                throw new Error('Tweak bigger than curve order');
            }
            let derivedPublicKey = null;
            try {
                if (privateKey) {
                    // Private parent key -> private child key
                    (0, _assert_1.bytes)(privateKey, 32);
                    (0, _assert_1.bytes)(derivedPrivateKey, 32);
                    const privateKeyBn = utils_1.TypeUtils.bytesToNumber(privateKey);
                    const childTweakBn = utils_1.TypeUtils.bytesToNumber(derivedPrivateKey);
                    const added = secp256k1_1.schnorr.utils.mod(privateKeyBn + childTweakBn, secp256k1_1.secp256k1.CURVE.n);
                    if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(added)) {
                        throw new Error('The tweak was out of range or the resulted private key is invalid');
                    }
                    derivedPrivateKey = utils_1.TypeUtils.numberToBytes(added);
                }
                else {
                    // Public parent key -> public child key
                    derivedPublicKey = yield this.getKeyFactory().publicKeyTweakAdd(publicKey, derivedPrivateKey, true);
                }
            }
            catch (err) {
                return this.deriveChild(index + 1);
            }
            return this.createChildHDKey(index, derivedPrivateKey, derivedChainCode, derivedPublicKey);
        });
    }
}
exports.HDKeySecp256k1 = HDKeySecp256k1;
