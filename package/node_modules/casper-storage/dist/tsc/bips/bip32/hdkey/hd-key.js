"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HDKey = void 0;
const cryptography_1 = require("../../../cryptography");
const utils_1 = require("../../../utils");
/**
 * Length of fields to serialize a data presents for a HD key
 * 4 bytes: Version byte (mainnet: 0x0488B21E public, 0x0488ADE4 private; testnet: 0x043587CF public, 0x04358394 private)
 * 1 byte: Depth (0x00 for master, 0x01 for next level derived keys)
 * 4 bytes: The fingerprint of parent's key (0x00000000 for master)
 * 4 bytes: child index (0x00000000 if master key)
 * 32 bytes: chain code
 * 33 bytes: the public key or private key
 */
const LENGHT = 78;
const HARDENED_OFFSET = 0x80000000;
/**
 * A component for BIP32
 * Original source code from https://github.com/cryptocoinjs/hdkey.
 * Refer and take inspiration to implement a generic HDKey
 */
class HDKey {
    /**
     * Construct a new HD key
     * @param config drive the encryption mode and address generator
     * @param privateKey the private key
     * @param chainCode the chain code
     * @param publicKey optional public key to derive children
     */
    constructor(config, privateKey, chainCode, publicKey) {
        this.path = "m"; // Default master path
        this.depth = 0x00;
        this.index = 0x00000000;
        this.parentFingerprint = 0x00000000;
        this.config = config;
        this.privateKey = privateKey;
        this.chainCode = chainCode;
        this.publicKey = publicKey;
    }
    /**
     * Returns the current path
     * @returns
     */
    getPath() {
        return this.path;
    }
    /**
     * Returns the private key Uint8Array
     * @returns
     */
    getPrivateKey() {
        return this.privateKey;
    }
    /**
     * Returns the chain code Uint8Array
     * @returns
     */
    getChainCode() {
        return this.chainCode;
    }
    /**
     * It creates a public key from the private key.
     * @returns
     */
    getPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.publicKey) {
                this.publicKey = yield this.getKeyFactory().createPublicKey(this.privateKey, true);
            }
            return Promise.resolve(this.publicKey);
        });
    }
    /**
     * Returns the private extended key (hex string)
     * @returns
     */
    getPrivateExtendedKey() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.privateKey) {
                throw new Error("Cannot compute privateExtendedKey without privateKey");
            }
            const data = utils_1.TypeUtils.concatBytes(utils_1.TypeUtils.getBytesOfZero(), this.privateKey);
            const result = cryptography_1.EncoderUtils.encodeBase58(this.serialize(this.config.versions.private, data));
            return Promise.resolve(result);
        });
    }
    /**
     * Returns the public extended key (hex string)
     * @returns
     */
    getPublicExtendedKey() {
        return __awaiter(this, void 0, void 0, function* () {
            const publicKey = yield this.getPublicKey();
            return Promise.resolve(cryptography_1.EncoderUtils.encodeBase58(this.serialize(this.config.versions.public, publicKey)));
        });
    }
    /**
     * Returns the fingerprint
     */
    getFingerprint() {
        return __awaiter(this, void 0, void 0, function* () {
            const publicKey = yield this.getPublicKey();
            const identifier = cryptography_1.CryptoUtils.hash160(publicKey);
            const view = new DataView(identifier.buffer, 0);
            const fingerprint = view.getUint32(0);
            return Promise.resolve(fingerprint);
        });
    }
    /**
     * Returns the parent fingerprint
     */
    getParentFingerPrint() {
        return this.depth === 0 ? 0x00000000 : this.parentFingerprint;
    }
    /**
     * Derive a HD key from the given path
     * @param path
     * @returns
     */
    derive(path) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line  @typescript-eslint/no-this-alias
            let hdKey = this;
            if (/^[mM]'?$/.test(path)) {
                return Promise.resolve(hdKey);
            }
            // Parts of path are separated by /
            const levels = path.split("/");
            let accumulatedPath = "";
            for (let levelIndex = 0; levelIndex < levels.length; levelIndex++) {
                const level = levels[levelIndex];
                if (levelIndex > 0)
                    accumulatedPath += "/";
                accumulatedPath += level;
                if (levelIndex === 0) {
                    if (level !== "m" && level !== "M") {
                        throw new Error("Path must start with m or M");
                    }
                    continue;
                }
                let childIndex = parseInt(level, 10);
                if (!Number.isSafeInteger(childIndex) || childIndex >= HARDENED_OFFSET) {
                    throw new Error("Invalid index");
                }
                childIndex = this.getHardenedIndex(childIndex, (level.length > 1) && (level[level.length - 1] === "'"));
                hdKey = yield hdKey.deriveChild(childIndex);
                hdKey.path = accumulatedPath;
            }
            return Promise.resolve(hdKey);
        });
    }
    createChildHDKey(index, privateKey, chainCode, publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = this.createNewHDKey(privateKey, chainCode, publicKey);
            key.index = index;
            key.depth = this.depth + 1;
            key.parentFingerprint = yield this.getFingerprint();
            return key;
        });
    }
    getHardenedOffset() {
        return HARDENED_OFFSET;
    }
    /**
     * Index should be hardened
     * @param index
     * @param hardened
     * @returns
     */
    getHardenedIndex(index, hardened) {
        if (hardened)
            index += this.getHardenedOffset();
        return index;
    }
    /**
     * Combine all relevance information of current node into a single array
     * @param version of private key or public key
     * @param key either private key of public key
     * @returns
     */
    serialize(version, key) {
        const ab = new ArrayBuffer(LENGHT);
        const view = new DataView(ab);
        view.setUint32(0, version);
        view.setUint8(4, this.depth);
        const fingerprint = this.getParentFingerPrint();
        view.setUint32(5, fingerprint);
        view.setUint32(9, this.index);
        this.getChainCode().forEach((val, index) => {
            view.setUint8(13 + index, val);
        });
        key.forEach((val, index) => {
            view.setUint8(45 + index, val);
        });
        return new Uint8Array(ab);
    }
    /**
     * Get the asymetric key wrapper to serialize data
     * @returns
     */
    getKeyFactory() {
        return cryptography_1.AsymmetricKeyFactory.getInstance(this.config.encryptionType);
    }
}
exports.HDKey = HDKey;
