"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HDKeyManagerBase = void 0;
const cryptography_1 = require("../../cryptography");
const utils_1 = require("../../utils");
/**
 * Default versions
 */
const BITCOIN_VERSIONS = { private: 0x0488ADE4, public: 0x0488B21E };
/**
 * Minimum length of master seed
 */
const MIN_SEED_LENGTH_BITS = 128;
const MIN_SEED_LENGTH_BYTES = MIN_SEED_LENGTH_BITS / 8;
/**
 * Base HDKey manager, to initialize the root key from the master seed.
 */
class HDKeyManagerBase {
    /**
     * The constructor function takes a single parameter, which is the encryption type
     * @param {EncryptionType} encryptionType - EncryptionType
     */
    constructor(encryptionType) {
        this._encryptionType = encryptionType;
    }
    /**
     * Get the underlying encryption type
     */
    get encryptionType() {
        return this._encryptionType;
    }
    verifySeed(seed) {
        if (!seed || !seed.length) {
            throw new Error("Master seed is required");
        }
        if (seed.length < MIN_SEED_LENGTH_BYTES) {
            throw new Error(`Master seed is not strong enough. Expected length is greater than or equal to ${MIN_SEED_LENGTH_BYTES} but received ${seed.length}`);
        }
    }
    /**
     * Create a new HDKey object from a seed
     * @param {Hex} seed - The seed to use to generate the master key.
     * @param {Versions} [versions] - The version of the HDKey.
     * @returns The HDKey object.
     */
    fromMasterSeed(seed, versions) {
        this.verifySeed(utils_1.TypeUtils.parseHexToArray(seed));
        const { key, chainCode } = cryptography_1.CryptoUtils.digestSHA512(seed, this.GetMasterSecret());
        return this.createNewHDKey(key, chainCode, versions || BITCOIN_VERSIONS);
    }
    /**
     * Construct a new HD key with valid information
     * @param privateKey
     * @param chainCode
     * @param versions
     */
    createNewHDKey(privateKey, chainCode, versions) {
        if (!this.getKeyFactory().isValidPrivateKey(privateKey)) {
            throw new Error("The master secret is bad, which produces invalid private key");
        }
        return this.createNewHDKey_Unsafe(privateKey, chainCode, versions);
    }
    /**
     * Returns the asymetric key wrapper
     */
    getKeyFactory() {
        return cryptography_1.AsymmetricKeyFactory.getInstance(this.encryptionType);
    }
}
exports.HDKeyManagerBase = HDKeyManagerBase;
