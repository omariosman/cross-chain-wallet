"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultStorage = void 0;
const cryptography_1 = require("../../cryptography");
const utils_1 = require("../../utils");
const ENCRYPTED_PREFIX = "cps_encrypted_";
/**
 * Simple wrapper for localStorage of browser
 */
class DefaultStorage {
    constructor(_password) {
        this._password = _password;
        if (!this._password) {
            throw new Error("Password is required");
        }
    }
    set(key, value, password) {
        return __awaiter(this, void 0, void 0, function* () {
            const encryptedValue = yield this.encrypt(value, password);
            return this.getStorage().setItem(key, ENCRYPTED_PREFIX + encryptedValue.toString());
        });
    }
    get(key, password) {
        return __awaiter(this, void 0, void 0, function* () {
            const value = this.getStorage().getItem(key);
            if (utils_1.TypeUtils.isString(value) && value.startsWith(ENCRYPTED_PREFIX)) {
                return this.decrypt(value.substring(ENCRYPTED_PREFIX.length), password);
            }
            else {
                return value;
            }
        });
    }
    has(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getStorage().getItem(key) != null;
        });
    }
    remove(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getStorage().removeItem(key);
        });
    }
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getStorage().clear();
        });
    }
    updatePassword(newPassword) {
        return __awaiter(this, void 0, void 0, function* () {
            // Resync all existing keys
            const keys = yield this.getKeys();
            if (keys && keys.length) {
                // Get the existing item with previous password
                const tempValues = {};
                for (const key of keys) {
                    const value = yield this.get(key);
                    tempValues[key] = value;
                }
                // And set back with the new password
                for (const key in tempValues) {
                    yield this.set(key, tempValues[key], newPassword);
                }
            }
            // Update the new password to encrypt/decrypt values
            this._password = newPassword;
        });
    }
    getKeys() {
        const keys = [];
        for (const [key, value] of Object.entries(this.getStorage())) {
            if (utils_1.TypeUtils.isString(value) && value.startsWith(ENCRYPTED_PREFIX)) {
                keys.push(key);
            }
        }
        return Promise.resolve(keys);
    }
    isAvailable() {
        try {
            this.getStorage().getItem("__test__");
            return true;
        }
        catch (_) {
            return false;
        }
    }
    getStorage() {
        return localStorage;
    }
    encrypt(value, password) {
        return __awaiter(this, void 0, void 0, function* () {
            password = password || this._password;
            const encryptionValue = yield cryptography_1.AESUtils.encrypt(password, value);
            return encryptionValue;
        });
    }
    decrypt(value, password) {
        password = password || this._password;
        const encryptedValue = cryptography_1.EncryptionResult.parseFrom(value);
        return cryptography_1.AESUtils.decrypt(password, encryptedValue.value, encryptedValue.salt, encryptedValue.iv);
    }
}
exports.DefaultStorage = DefaultStorage;
