"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.User = void 0;
const wallet_1 = require("../wallet");
const cryptography_1 = require("../cryptography");
const wallet_info_1 = require("./wallet-info");
const password_options_1 = require("../cryptography/password-options");
/**
 * A user instance to manage HD wallet and legacy wallets with detailed information.
 * A user serialized value is secured by a secured password which is given by user.
 * We should never store user's password but its encrypted one to do extra actions.
 */
class User {
    /**
     * Deserialize user information to an instance of user
     * @param password
     * @param userEncryptedInfo
     * @param options Options to work with user's instance
     * @returns
     */
    static deserializeFrom(password, userEncryptedInfo, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = new User(password, options);
            yield user.deserialize(userEncryptedInfo);
            return user;
        });
    }
    /**
     * Initialize a new user instnace
     * @param password a secure password to encrypt/decrypt user's data
     * @param options Options to work with user's instance
     */
    constructor(password, options) {
        options = options || {};
        this._passwordValidator = options.passwordValidator || password_options_1.defaultValidator;
        this.validatePassword(password);
        this._pwdOptions = new password_options_1.PasswordOptions(password);
    }
    /**
     * Update password to serialize user's information.
     * A new salt will be generated regardless the given options.
     * @param password
     */
    updatePassword(password) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyPhrase = this._hdWalletInfo ? yield this.decrypt(this._hdWalletInfo.encryptedKeyPhrase) : null;
            this.validatePassword(password);
            this._pwdOptions = new password_options_1.PasswordOptions(password);
            if (keyPhrase)
                this._hdWalletInfo.encryptedKeyPhrase = yield this.encrypt(keyPhrase);
        });
    }
    setHDWallet(keyPhrase, encryptionType) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!keyPhrase)
                throw new Error("Key is required");
            if (!encryptionType)
                throw new Error("Type is required");
            this._hdWalletInfo = new wallet_info_1.HDWalletInfo(keyPhrase, encryptionType);
            this._hdWalletInfo.encryptedKeyPhrase = yield this.encrypt(keyPhrase);
            this._underlyingHDWallet = null;
        });
    }
    getHDWallet() {
        return this._hdWalletInfo;
    }
    getHDWalletKeyPhrase() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.decrypt(this._hdWalletInfo.encryptedKeyPhrase);
        });
    }
    getWalletAccount(index) {
        return this.getWallet().getAccount(index);
    }
    getWalletAccountByRefKey(idOrPath) {
        return this.getWallet().getWalletFromPath(idOrPath);
    }
    addWalletAccount(index, info) {
        return __awaiter(this, void 0, void 0, function* () {
            const acc = yield this.getWalletAccount(index);
            this.setHDWalletAccount(acc.getReferenceKey(), info);
            return this.getWalletAccount(index);
        });
    }
    removeWalletAccount(index) {
        return __awaiter(this, void 0, void 0, function* () {
            const acc = yield this.getWalletAccount(index);
            this._hdWalletInfo.removeDerivedWallet(acc.getReferenceKey());
        });
    }
    addLegacyWallet(wallet, info) {
        if (!this._legacyWallets)
            this._legacyWallets = [];
        const id = wallet.getReferenceKey();
        if (!info) {
            info = new wallet_info_1.WalletDescriptor("Legacy wallet " + (this._legacyWallets.length + 1));
        }
        // Try removing existing wallet
        this.removeWalletInfo(id);
        // Initialize and add new wallet
        const walletInfo = new wallet_info_1.WalletInfo(id, wallet.getEncryptionType(), info);
        this._legacyWallets.push(walletInfo);
    }
    getLegacyWallets() {
        return this._legacyWallets;
    }
    hasLegacyWallets() {
        return this._legacyWallets && this._legacyWallets.length > 0;
    }
    hasHDWallet() {
        return !!this.getHDWallet();
    }
    setWalletInfo(id, info) {
        let walletInfo = this.getWalletInfo(id);
        if (!walletInfo) {
            // The wallet does not exist yet, if the given id is a derived path of HD wallet
            // Automatically create one and insert it into the list
            if (this.isHDWalletPath(id) && this.hasHDWallet()) {
                this.setHDWalletAccount(id);
                walletInfo = this.getWalletInfo(id);
            }
            if (!walletInfo) {
                throw new Error(`The requesting wallet is not available ${id}`);
            }
        }
        walletInfo.descriptor = wallet_info_1.WalletDescriptor.from(info);
    }
    getWalletInfo(id) {
        let info = null;
        // Start with HD wallet (as we should in this mode instead of legacy)
        if (this._hdWalletInfo) {
            const derives = this._hdWalletInfo.derivedWallets;
            if (derives) {
                info = derives.find(x => x.id === id || x.uid === id);
            }
        }
        // No available HD wallet for given id, try with legacy ones
        if (!info) {
            if (this._legacyWallets) {
                info = this._legacyWallets.find(x => x.id === id || x.uid === id);
            }
        }
        return info;
    }
    removeWalletInfo(id) {
        // Start with HD wallet (as we should in this mode instead of legacy)
        if (this._hdWalletInfo) {
            const derives = this._hdWalletInfo.derivedWallets;
            if (derives) {
                const idx = derives.findIndex(x => x.id === id || x.uid === id);
                if (idx >= 0) {
                    derives.splice(idx, 1);
                    return;
                }
            }
        }
        if (this._legacyWallets) {
            const idx = this._legacyWallets.findIndex(x => x.id === id || x.uid === id);
            if (idx >= 0) {
                this._legacyWallets.splice(idx, 1);
            }
        }
    }
    /**
     * Serializes the wallet and encrypts it with the password.
     * @returns The encrypted wallet.
     */
    serialize() {
        return __awaiter(this, void 0, void 0, function* () {
            const obj = {
                hdWallet: this.getHDWallet(),
                legacyWallets: this.getLegacyWallets(),
            };
            const resultAsJSON = JSON.stringify(obj);
            const result = yield this.encrypt(resultAsJSON);
            return result;
        });
    }
    /**
     * Deserializes the serialized and encrypted user information to merge back the current user instance.
     * @param {string} value - serialized user information
     */
    deserialize(value) {
        return __awaiter(this, void 0, void 0, function* () {
            let decryptedValue;
            try {
                decryptedValue = yield this.decrypt(value);
            }
            catch (err) {
                throw new Error(`Unable to decrypt user information. Error: ${err}`);
            }
            try {
                const obj = JSON.parse(decryptedValue);
                if (obj.hdWallet) {
                    let keyPhrase = obj.hdWallet.keyPhrase;
                    if (!keyPhrase && obj.hdWallet.encryptedKeyPhrase) {
                        keyPhrase = yield this.decrypt(obj.hdWallet.encryptedKeyPhrase);
                    }
                    if (!keyPhrase) {
                        throw new Error(`Unable to find a vaid key-phrase to process HD wallet`);
                    }
                    yield this.setHDWallet(keyPhrase, obj.hdWallet.encryptionType);
                    if (obj.hdWallet.derives) {
                        obj.hdWallet.derives.forEach((wl) => {
                            this.setHDWalletAccount(wl.id, wl.descriptor);
                        });
                    }
                }
                if (obj.legacyWallets) {
                    this._legacyWallets = [];
                    obj.legacyWallets.forEach((wl) => {
                        this._legacyWallets.push(new wallet_info_1.WalletInfo(wl.id, wl.encryptionType, wl.descriptor));
                    });
                }
            }
            catch (err) {
                throw new Error(`Unable to parse user information. Error: ${err}. Value: ${decryptedValue}`);
            }
        });
    }
    encrypt(value) {
        return __awaiter(this, void 0, void 0, function* () {
            const encryption = yield cryptography_1.AESUtils.encrypt(this._pwdOptions.password, value);
            return encryption.toString();
        });
    }
    decrypt(value) {
        const encryptedValue = cryptography_1.EncryptionResult.parseFrom(value);
        return cryptography_1.AESUtils.decrypt(this._pwdOptions.password, encryptedValue.value, encryptedValue.salt, encryptedValue.iv);
    }
    getWallet() {
        if (!this._hdWalletInfo) {
            return null;
        }
        if (!this._underlyingHDWallet) {
            this._underlyingHDWallet = new wallet_1.CasperHDWallet(this._hdWalletInfo.keySeed, this._hdWalletInfo.encryptionType); // ! Hardcoded to Casper for now
        }
        return this._underlyingHDWallet;
    }
    setHDWalletAccount(id, info) {
        this._hdWalletInfo.setDerivedWallet(id, this.getHDWallet().encryptionType, info);
    }
    /**
    * Check if the given id belongs to a HD wallet.
    * The id of a HD wallet should be a path
    * @param id
    * @returns
    */
    isHDWalletPath(id) {
        return id.indexOf('/') >= 0;
    }
    /**
     * Confirms the given password matches requirements
     * @param password
     */
    validatePassword(password) {
        const validator = this._passwordValidator;
        if (validator.validatorFunc) {
            const result = validator.validatorFunc(password);
            if (!result) {
                throw new Error("The password validator failed to run");
            }
            if (!result.status) {
                throw new Error(result.message);
            }
        }
        if (validator.validatorRegex) {
            if (!new RegExp(validator.validatorRegex).test(password)) {
                throw new Error("Password is not strong enough");
            }
        }
    }
}
exports.User = User;
