"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HDWalletInfo = exports.WalletInfo = exports.WalletDescriptor = void 0;
const key_1 = require("../key");
const cryptography_1 = require("../cryptography");
const utils_1 = require("../utils");
/**
 * Descriptor of a wallet
 * e.g name, icon, etc
 */
class WalletDescriptor {
    /**
     * Create a new instance of the `WalletDescriptor` class
     * @param {string} [_name] - The name of wallet.
     * @param {string} [_icon] - The icon of wallet.
     * @param {string} [_description] - The description of wallet.
     */
    constructor(_name, _icon, _description) {
        this._name = _name;
        this._icon = _icon;
        this._description = _description;
    }
    /**
     * Get the name of wallet
     * @returns The name of wallet.
     */
    get name() {
        return this._name;
    }
    /**
     * It sets the name of wallet.
     * @param {string} name - The name of wallet.
     */
    set name(name) {
        this._name = name;
    }
    /**
     * Get the icon of wallet
     * @returns The icon of wallet.
     */
    get icon() {
        return this._icon;
    }
    /**
     * It sets the icon of wallet.
     * @param {string} icon - The icon of wallet.
     */
    set icon(icon) {
        this._icon = icon;
    }
    /**
     * Get the description of wallet
     * @returns The description of wallet.
     */
    get description() {
        return this._description;
    }
    /**
     * It sets the description of wallet.
     * @param {string} description - The description of wallet.
     */
    set description(description) {
        this._description = description;
    }
    /**
     * It creates a WalletDescriptor object from a string or object.
     * @param {string | WalletDescriptor} info - string | WalletDescriptor
     * @returns A WalletDescriptor object.
     */
    static from(info) {
        if (!info) {
            return new WalletDescriptor();
        }
        let descriptor;
        if (utils_1.TypeUtils.isString(info)) {
            descriptor = new WalletDescriptor(info);
        }
        else {
            const infoObj = info;
            descriptor = new WalletDescriptor(infoObj.name, infoObj.icon, infoObj.description);
        }
        return descriptor;
    }
    /**
     * Override the JSOn stringify behavior to have properly properties
     */
    toJSON() {
        return {
            name: this.name,
            icon: this.icon,
            description: this.description,
        };
    }
}
exports.WalletDescriptor = WalletDescriptor;
/**
 * Wallet information
 * - Wallet id (private key or derived path)
 * - Encryption type
 * - Descriptor (name, icon, etc)
 */
class WalletInfo {
    /**
     * Create a new wallet information with key and encryption type
     * @param id
     * @param type
     * @param info
     */
    constructor(id, type, info) {
        if (!id)
            throw new Error("Key is required");
        if (!type)
            throw new Error("Type is required");
        this._id = id;
        this._encryptionType = type;
        this._descriptor = WalletDescriptor.from(info);
    }
    /**
     * Get id of wallet (private key or derived path)
     */
    get id() {
        return this._id;
    }
    /**
     * Get uid (hashed of id) of wallet
     */
    get uid() {
        if (!this._uid) {
            const id = cryptography_1.EncoderUtils.encodeText(this.id);
            this._uid = utils_1.TypeUtils.convertArrayToHexString(cryptography_1.CryptoUtils.hash256(id));
        }
        return this._uid;
    }
    /**
     * Get the encryption type of wallet
     */
    get encryptionType() {
        return this._encryptionType;
    }
    /**
     * Get descriptor of wallet
     */
    get descriptor() {
        return this._descriptor;
    }
    /**
     * Set descriptor of wallet
     */
    set descriptor(info) {
        this._descriptor = info;
    }
    /**
     * Get the account index (only applicable for wallets from HD wallet)
     */
    get index() {
        const parts = this.id.split('/');
        if (parts.length < 4) {
            throw new Error("This is not a HD wallet account");
        }
        const index = parseInt(parts[3]); // ' will be ignored
        if (isNaN(index)) {
            throw new Error("This is not a HD wallet account");
        }
        return index;
    }
    /**
     * Returns true if this is a legacy wallet
     */
    get isLegacy() {
        return !this.isHDWallet;
    }
    /**
     * Returns true if this is a HD wallet
     */
    get isHDWallet() {
        return this.id.indexOf('/') >= 0;
    }
    /**
     * Override the JSOn stringify behavior to have properly properties
     */
    toJSON() {
        return {
            id: this.id,
            uid: this.uid,
            encryptionType: this.encryptionType,
            descriptor: this.descriptor
        };
    }
}
exports.WalletInfo = WalletInfo;
/**
 * HD wallet information
 * With the master key and specific encryption type
 */
class HDWalletInfo {
    /**
     * Create a new HD wallet information with master key and encryption type
     * @param key
     * @param encryptionType
     */
    constructor(key, encryptionType) {
        if (!key)
            throw new Error("Key phrase (master key) is required");
        if (!encryptionType)
            throw new Error("Type is required");
        if (key.indexOf(" ") > 0) {
            this._keySeed = key_1.KeyFactory.getInstance().toSeed(key);
        }
        else {
            this._keySeed = key;
        }
        this._encryptionType = encryptionType;
    }
    /**
     * Get encrypted key-phrase
     */
    get encryptedKeyPhrase() {
        return this._encryptedKeyPhrase;
    }
    /**
     * Set encrypted key-phrase
     */
    set encryptedKeyPhrase(value) {
        this._encryptedKeyPhrase = value;
    }
    /**
     * Get encryption type of wallet
     */
    get encryptionType() {
        return this._encryptionType;
    }
    /**
     * Get derived wallets
     */
    get derivedWallets() {
        return this._derivedWallets;
    }
    /**
     * Get the key-seed (from the keyphrase)
     */
    get keySeed() {
        return this._keySeed;
    }
    /**
     * Set a derived wallet information
     * @param derivedPath
     * @param encryptionType
     * @param info
     */
    setDerivedWallet(derivedPath, encryptionType, info) {
        if (!this._derivedWallets)
            this._derivedWallets = [];
        let derived = null;
        for (const item of this._derivedWallets) {
            if (item.id == derivedPath) {
                derived = item;
                break;
            }
        }
        if (!derived) {
            derived = new WalletInfo(derivedPath, encryptionType);
            this._derivedWallets.push(derived);
        }
        if (info) {
            derived.descriptor = WalletDescriptor.from(info);
        }
        else {
            derived.descriptor = WalletDescriptor.from("Account " + (derived.index + 1));
        }
    }
    /**
     * Remove a derived wallet by path
     * @param derivedPath
     */
    removeDerivedWallet(derivedPath) {
        if (this._derivedWallets) {
            this._derivedWallets = this._derivedWallets.filter((x) => x.id != derivedPath);
        }
    }
    /**
     * Override the JSOn stringify behavior to have properly properties
     */
    toJSON() {
        return {
            encryptedKeyPhrase: this.encryptedKeyPhrase,
            keySeed: this.keySeed,
            encryptionType: this.encryptionType,
            derives: this.derivedWallets
        };
    }
}
exports.HDWalletInfo = HDWalletInfo;
