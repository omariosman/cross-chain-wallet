"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HDWallet = void 0;
const bip32_1 = require("../../bips/bip32");
const cryptography_1 = require("../../cryptography");
const utils_1 = require("../../utils");
/**
 * Hierarchical Deterministic Wallets (BIP32)
 * Standard for deterministic wallets that can be interchanged between different clients.
 */
class HDWallet {
    constructor(walletConstructor, coinPath, encryptionType, masterSeed) {
        if (!walletConstructor) {
            throw new Error("The wallet constructor must be provided");
        }
        if (!coinPath) {
            throw new Error("The base coint path must be provided");
        }
        if (encryptionType == null || (encryptionType !== cryptography_1.EncryptionType.Ed25519 && encryptionType !== cryptography_1.EncryptionType.Secp256k1)) {
            throw new Error("The encryption type must be provided (e.g: EncryptionType.Ed25519 or EncryptionType.Secp256k1)");
        }
        this.walletConstructor = walletConstructor;
        this.coinPath = coinPath;
        this.encryptionType = encryptionType;
        this.masterSeed = utils_1.TypeUtils.parseHexToArray(masterSeed);
        this.getHDKeyManager().verifySeed(this.masterSeed);
    }
    getEncryptionType() {
        return this.encryptionType;
    }
    getCoinPath() {
        return this.coinPath;
    }
    getMasterKey() {
        if (!this._masterKey) {
            this._masterKey = this.getHDKeyManager().fromMasterSeed(this.masterSeed);
        }
        return this._masterKey;
    }
    getMasterWallet() {
        return this.getWalletFromPath("m");
    }
    getAccount(index, internal) {
        return this.getWalletFromPath(this.coinPath.createPath(index, internal));
    }
    getWallet(accountIndex, internal, walletIndex) {
        if (walletIndex === null || walletIndex === undefined) {
            walletIndex = accountIndex;
            accountIndex = 0;
        }
        return this.getWalletFromPath(this.coinPath.createPath(accountIndex, internal, walletIndex));
    }
    getWalletFromPath(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const hdKey = yield this.getMasterKey().derive(path);
            return Promise.resolve(new this.walletConstructor(hdKey, this.encryptionType));
        });
    }
    /**
     * Get the HD key manager
     * @returns
     */
    getHDKeyManager() {
        return bip32_1.HDKeyManagerFactory.getInstance(this.encryptionType);
    }
}
exports.HDWallet = HDWallet;
