"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeUtils = void 0;
const utils_1 = require("@noble/hashes/utils");
/**
 * Provide utiltiies to work with types
 * - Convert hex value between types string and array of uint8
 * - Check types
 */
class TypeUtils {
    /**
     * A byte-array of Zero
     */
    static getBytesOfZero() {
        return new Uint8Array([0]);
    }
    /**
     * Convert the given array value to a hex string
     * @param input hex array
     * @returns
     */
    static convertArrayToHexString(input) {
        if (!input)
            return null;
        return [...new Uint8Array(input)].map((x) => x.toString(16).padStart(2, '0')).join('');
    }
    /**
     * Convert an array of bytes to a string of binary digits
     * @param {Uint8Array} input - The input array of bytes.
     * @param [bitsPerValue=8] - The number of bits to use per value.
     * @returns The binary string representation of the input array.
     */
    static convertArrayToBinaryString(input, bitsPerValue = 8) {
        if (!input)
            return null;
        return [...input].map((x) => x.toString(2).padStart(bitsPerValue, '0')).join('');
    }
    /**
     * Convert the given hex string to an Uint8Array
     * @param input hex string
     * @returns
     */
    static convertHexStringToArray(input) {
        if (!input)
            return new Uint8Array();
        return new Uint8Array(input.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
    }
    /**
     * It takes a hex value and converts it to a Uint8Array.
     * @param {Hex} input - The input to be converted to a Uint8Array.
     * @returns a `Uint8Array` object
     */
    static parseHexToArray(input) {
        if (TypeUtils.isString(input)) {
            return TypeUtils.convertHexStringToArray(input);
        }
        return input;
    }
    /**
     * It takes a hex value and converts it to a hex string.
     * @param {Hex} input - The input to be converted to a string.
     * @returns The hex string representation of the input.
     */
    static parseHexToString(input) {
        if (TypeUtils.isString(input)) {
            return input;
        }
        return TypeUtils.convertArrayToHexString(input);
    }
    /**
     * It checks if the input is a string or a string instance.
     * @param {any} input - any
     * @returns `true` or `false`
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static isString(input) {
        return typeof input === 'string' || input instanceof String;
    }
    /**
     * Convert bytes to a bigint number
     * @param bytes
     * @returns
     */
    static bytesToNumber(bytes) {
        return BigInt(`0x${(0, utils_1.bytesToHex)(bytes)}`);
    }
    /**
     * Convert a bigint number to bytes
     * @param num
     * @returns
     */
    static numberToBytes(num) {
        return (0, utils_1.hexToBytes)(num.toString(16).padStart(64, '0'));
    }
    /**
     * Convert U32 number to bytes
     * @param n
     * @returns
     */
    static convertU32ToBytes(n) {
        if (!Number.isSafeInteger(n) || n < 0 || n > Math.pow(2, 32) - 1) {
            throw new Error(`Invalid number=${n}. Should be from 0 to 2 ** 32 - 1`);
        }
        const buf = new Uint8Array(4);
        (0, utils_1.createView)(buf).setUint32(0, n, false);
        return buf;
    }
    /**
     * Concat multiple byte-arrays into one
     * @param arrays
     * @returns
     */
    static concatBytes(...arrays) {
        return (0, utils_1.concatBytes)(...arrays);
    }
}
exports.TypeUtils = TypeUtils;
