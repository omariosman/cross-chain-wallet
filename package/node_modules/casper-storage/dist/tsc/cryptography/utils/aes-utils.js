"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AESUtils = exports.EncryptionResult = void 0;
const utils_1 = require("../../utils");
const _1 = require(".");
/**
 * Represents the result of encryption with additional data
 */
class EncryptionResult {
    /**
     * Parse the encrypted value back the result
     * @param encryptedValue
     * @returns
     */
    static parseFrom(encryptedValue) {
        const valueObj = JSON.parse(encryptedValue);
        return new EncryptionResult(valueObj.value, new Uint8Array(valueObj.salt), new Uint8Array(valueObj.iv));
    }
    constructor(value, salt, iv) {
        this.value = value;
        this.salt = salt;
        this.iv = iv;
        // Noop
    }
    /**
     * Serialize encryption result to a string
     * @returns
     */
    toString() {
        return JSON.stringify({ value: this.value, salt: Array.from(this.salt), iv: Array.from(this.iv) });
    }
}
exports.EncryptionResult = EncryptionResult;
/**
 * AES enryption utils
 * Provide functions to encrypt a text with a secure  password
 * and also be able to decrypt the encrypted value back to the original text with that secure password
 */
class AESUtils {
    /**
     * Encrypts a value
     *
     * @param {string} password - The password to encrypt value.
     * @param {string} value - The value to encrypt.
     * @param {string} mode - The AES mode to encrypt value (default is AES-GCM).
     * @returns The encrypted value with a random generated salt
     */
    static encrypt(password, value, mode = "AES-GCM") {
        return __awaiter(this, void 0, void 0, function* () {
            if (!password)
                throw new Error("Key is required");
            if (!value)
                throw new Error("Value is required");
            if (!mode)
                throw new Error("Encrypt mode is required");
            const crypto = _1.CryptoUtils.getCrypto();
            const salt = _1.CryptoUtils.randomBytes(16);
            const iv = _1.CryptoUtils.randomBytes(16);
            const key = yield AESUtils.importKey(password, salt, mode);
            // Encoded value
            const valueBytes = _1.EncoderUtils.encodeText(value);
            const cipherValue = yield crypto.subtle.encrypt({ name: mode, iv: iv }, key, valueBytes);
            // Convert the encrypted bytes to a hex string
            const hexValue = utils_1.TypeUtils.convertArrayToHexString(cipherValue);
            return new EncryptionResult(hexValue, salt, iv);
        });
    }
    /**
     * Decrypts a value
     *
     * @param {string} password - The password to decrypt value.
     * @param {string} value - The value to decrypt.
     * @param {string} iv - The additional data for encryption.
     * @param {string} mode - The AES mode to decrypt value (default is AES-GCM).
     * @returns The decrypted value.
     */
    static decrypt(password, value, salt, iv, mode = "AES-GCM") {
        return __awaiter(this, void 0, void 0, function* () {
            if (!password)
                throw new Error("Key is required");
            if (!value)
                throw new Error("Value is required");
            if (!salt)
                throw new Error("Salt is required");
            if (!iv)
                throw new Error("IV is required");
            if (!mode)
                throw new Error("Encrypt mode is required");
            // Parse to array
            salt = utils_1.TypeUtils.parseHexToArray(salt);
            iv = utils_1.TypeUtils.parseHexToArray(iv);
            const key = yield AESUtils.importKey(password, salt, mode);
            // Convert the encrypted value into a byte array
            const valueBytes = utils_1.TypeUtils.parseHexToArray(value);
            const decryptedValue = yield crypto.subtle.decrypt({ name: mode, iv: iv }, key, valueBytes);
            const decryptedText = _1.EncoderUtils.decodeText(decryptedValue);
            return decryptedText;
        });
    }
    static importKey(password, salt, mode) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyBytes = _1.CryptoUtils.scrypt(password, salt);
            const crypto = _1.CryptoUtils.getCrypto();
            const key = yield crypto.subtle.importKey("raw", keyBytes, { "name": mode, length: 256 }, false, ["encrypt", "decrypt"]);
            return key;
        });
    }
}
exports.AESUtils = AESUtils;
