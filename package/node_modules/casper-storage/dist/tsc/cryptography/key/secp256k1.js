"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Secp256k1 = void 0;
const secp256k1_1 = require("@noble/curves/secp256k1");
const base_1 = require("@scure/base");
const key_encoder_1 = __importDefault(require("key-encoder"));
const utils_1 = require("../../utils");
const keyEncoder = new key_encoder_1.default("secp256k1");
/**
 * Minimal wrapper to secp256k1
 */
class KeyWrapper {
    generatePrivateKey() {
        return Promise.resolve(secp256k1_1.secp256k1.utils.randomPrivateKey());
    }
    createPublicKey(privateKey, compressed) {
        // Ensure we have valid byte-array
        privateKey = utils_1.TypeUtils.parseHexToArray(privateKey);
        return Promise.resolve(secp256k1_1.secp256k1.getPublicKey(privateKey, compressed));
    }
    publicKeyTweakAdd(publicKey, tweak, compressed) {
        return new Promise((resolve) => {
            // Ensure we have valid byte-array
            publicKey = utils_1.TypeUtils.parseHexToArray(publicKey);
            tweak = utils_1.TypeUtils.parseHexToArray(tweak);
            const publicPoint = secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey);
            const tweakPoint = secp256k1_1.secp256k1.ProjectivePoint.fromHex(tweak);
            return resolve(publicPoint.add(tweakPoint).toRawBytes(compressed));
        });
    }
    isValidPrivateKey(privateKey) {
        const privateKeyNumber = utils_1.TypeUtils.bytesToNumber(utils_1.TypeUtils.parseHexToArray(privateKey));
        if (privateKeyNumber == BigInt(0) || privateKeyNumber >= secp256k1_1.secp256k1.CURVE.n) {
            return false;
        }
        return true;
    }
    getKeyInPEM(key, isPrivate) {
        if (isPrivate) {
            return keyEncoder.encodePrivate(base_1.base16.encode(key), "raw", "pem");
        }
        else {
            return keyEncoder.encodePublic(base_1.base16.encode(key), "raw", "pem");
        }
    }
}
exports.Secp256k1 = new KeyWrapper();
