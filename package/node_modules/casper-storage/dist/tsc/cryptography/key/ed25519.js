"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ed25519 = void 0;
const utils_1 = require("../../utils");
const ed25519_1 = require("@noble/curves/ed25519");
const base_1 = require("@scure/base");
const ED25519_PEM_SECRET_KEY_TAG = 'PRIVATE KEY';
const ED25519_PEM_PUBLIC_KEY_TAG = 'PUBLIC KEY';
const PRIVATE_DER_PREFIX = new Uint8Array([48, 46, 2, 1, 0, 48, 5, 6, 3, 43, 101, 112, 4, 34, 4, 32]);
const PUBLIC_DER_PREFIX = new Uint8Array([48, 42, 48, 5, 6, 3, 43, 101, 112, 3, 33, 0]);
/**
 * Minimal wrapper to ed25519
 */
class KeyWrapper {
    generatePrivateKey() {
        return Promise.resolve(ed25519_1.ed25519.utils.randomPrivateKey());
    }
    createPublicKey(privateKey) {
        // Ensure we have valid byte-array
        privateKey = utils_1.TypeUtils.parseHexToArray(privateKey);
        return Promise.resolve(ed25519_1.ed25519.getPublicKey(utils_1.TypeUtils.parseHexToArray(privateKey)));
    }
    publicKeyTweakAdd() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("This method is not supported");
        });
    }
    isValidPrivateKey() {
        // For ed25519, the last step always succeeds since every 256-bit number (even 0) is a valid private key.
        return true;
    }
    getKeyInPEM(key, isPrivate) {
        if (isPrivate) {
            const encoded = base_1.base64.encode(utils_1.TypeUtils.concatBytes(PRIVATE_DER_PREFIX, key));
            return this.toPem(ED25519_PEM_SECRET_KEY_TAG, encoded);
        }
        else {
            const encoded = base_1.base64.encode(utils_1.TypeUtils.concatBytes(PUBLIC_DER_PREFIX, key));
            return this.toPem(ED25519_PEM_PUBLIC_KEY_TAG, encoded);
        }
    }
    /**
    * Inserts the provided `content` and `tag` into a .pem compliant string
    * @param tag The tag inserted on the END line
    * @param content The base-64 PEM compliant private key
    */
    toPem(tag, content) {
        return `-----BEGIN ${tag}-----
${content}
-----END ${tag}-----`;
    }
}
exports.Ed25519 = new KeyWrapper();
